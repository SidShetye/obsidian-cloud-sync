"use strict";(self.webpackChunkcloud_sync=self.webpackChunkcloud_sync||[]).push([[949],{74949(e,t,r){r.d(t,{EventStreamSerde:()=>i});var n=r(34481),s=r(71756);class i{marshaller;serializer;deserializer;serdeContext;defaultContentType;constructor({marshaller:e,serializer:t,deserializer:r,serdeContext:n,defaultContentType:s}){this.marshaller=e,this.serializer=t,this.deserializer=r,this.serdeContext=n,this.defaultContentType=s}async serializeEventStream({eventStream:e,requestSchema:t,initialRequest:r}){const n=this.marshaller,s=t.getEventStreamMember(),i=t.getMemberSchema(s),a=this.serializer,o=this.defaultContentType,l=Symbol("initialRequestMarker"),c={async*[Symbol.asyncIterator](){if(r){const e={":event-type":{type:"string",value:"initial-request"},":message-type":{type:"string",value:"event"},":content-type":{type:"string",value:o}};a.write(t,r);const n=a.flush();yield{[l]:!0,headers:e,body:n}}for await(const t of e)yield t}};return n.serialize(c,e=>{if(e[l])return{headers:e.headers,body:e.body};const t=Object.keys(e).find(e=>"__type"!==e)??"",{additionalHeaders:r,body:n,eventType:s,explicitPayloadContentType:a}=this.writeEventBody(t,i,e);return{headers:{":event-type":{type:"string",value:s},":message-type":{type:"string",value:"event"},":content-type":{type:"string",value:a??o},...r},body:n}})}async deserializeEventStream({response:e,responseSchema:t,initialResponseContainer:r}){const s=this.marshaller,i=t.getEventStreamMember(),a=t.getMemberSchema(i).getMemberSchemas(),o=Symbol("initialResponseMarker"),l=s.deserialize(e.body,async e=>{const r=Object.keys(e).find(e=>"__type"!==e)??"",s=e[r].body;if("initial-response"===r){const e=await this.deserializer.read(t,s);return delete e[i],{[o]:!0,...e}}if(r in a){const t=a[r];if(t.isStructSchema()){const i={};let a=!1;for(const[o,l]of t.structIterator()){const{eventHeader:t,eventPayload:c}=l.getMergedTraits();if(a=a||Boolean(t||c),c)l.isBlobSchema()?i[o]=s:l.isStringSchema()?i[o]=(this.serdeContext?.utf8Encoder??n.P)(s):l.isStructSchema()&&(i[o]=await this.deserializer.read(l,s));else if(t){const t=e[r].headers[o]?.value;null!=t&&(l.isNumericSchema()?i[o]=t&&"object"==typeof t&&"bytes"in t?BigInt(t.toString()):Number(t):i[o]=t)}}if(a)return{[r]:i};if(0===s.byteLength)return{[r]:{}}}return{[r]:await this.deserializer.read(t,s)}}return{$unknown:e}}),c=l[Symbol.asyncIterator](),d=await c.next();if(d.done)return l;if(d.value?.[o]){if(!t)throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");for(const[e,t]of Object.entries(d.value))r[e]=t}return{async*[Symbol.asyncIterator](){for(d?.value?.[o]||(yield d.value);;){const{done:e,value:t}=await c.next();if(e)break;yield t}}}}writeEventBody(e,t,r){const n=this.serializer;let i,a=e,o=null;const l={};if(t.getSchema()[4].includes(e)){const s=t.getMemberSchema(e);if(!s.isStructSchema())throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.");for(const[t,n]of s.structIterator()){const{eventHeader:s,eventPayload:i}=n.getMergedTraits();if(i)o=t;else if(s){const s=r[e][t];let i="binary";n.isNumericSchema()?i=(-2)**31<=s&&s<=2**31-1?"integer":"long":n.isTimestampSchema()?i="timestamp":n.isStringSchema()?i="string":n.isBooleanSchema()&&(i="boolean"),null!=s&&(l[t]={type:i,value:s},delete r[e][t])}}if(null!==o){const t=s.getMemberSchema(o);t.isBlobSchema()?i="application/octet-stream":t.isStringSchema()&&(i="text/plain"),n.write(t,r[e][o])}else n.write(s,r[e])}else{const[t,s]=r[e];a=t,n.write(15,s)}const c=n.flush();return{body:"string"==typeof c?(this.serdeContext?.utf8Decoder??s.a)(c):c,eventType:a,explicitPayloadContentType:i,additionalHeaders:l}}}}}]);